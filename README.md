# Module 8 Tutorial: High-Level Networking

Advanced Programming (Even Semester 2024/2025) Tutorial Module 8

Khansa Khairunisa - 2306152462

## Reflection

>1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?

`Unary`, `server streaming`, dan `bi-directional streaming RPC` merupakan tiga pola komunikasi yang berbeda dalam gRPC, ditentukan oleh bagaimana data dikirim dan diterima antara client dan server. Pada `unary RPC`, client mengirim satu permintaan dan menunggu untuk menerima respons dari server (server memberikan satu balasan). Pola ini merupakan pola yang paling sederhana dan cocok untuk operasi singkat seperti memverifikasi akun, mendapatkan data tunggal, atau menyimpan satu entri ke database. `Server streaming RPC` memungkinkan client mengirim satu permintaan, lalu server membalas dengan banyak pesan secara bertahap. Ini sangat berguna dalam situasi seperti mengirim log aktivitas, daftar histori transaksi, atau notifikasi berurutan dari server. Sementara `bi-directional streaming RPC` memungkinkan client dan server mengirim banyak pesan secara bersamaan dalam satu koneksi. Keduanya bisa membaca dan menulis secara independen. Pola ini paling cocok untuk aplikasi yang membutuhkan komunikasi dua arah secara real-time, seperti layanan customer support berbasis chat atau sistem trading langsung.

>2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?

Saat membangun layanan gRPC di Rust, ada beberapa aspek keamanan penting yang perlu diperhatikan. Pertama, autentikasi diperlukan agar server dapat memastikan bahwa setiap permintaan berasal dari sumber yang sah. Ini bisa dilakukan melalui penggunaan token seperti JWT atau sistem otentikasi berbasis sertifikat. Selanjutnya, autorisasi berfungsi untuk membatasi hak akses berdasarkan identitas pengguna. Implementasinya bisa berbentuk pengecekan peran atau izin di middleware sebelum request diproses lebih lanjut. Terakhir, enkripsi data adalah hal wajib agar komunikasi antara client dan server tetap aman dari penyadapan. gRPC mendukung komunikasi menggunakan TLS, yang memastikan data tidak bisa dibaca atau dimodifikasi oleh pihak ketiga selama dalam perjalanan. Tanpa pengamanan ini, sistem akan rentan terhadap serangan seperti replay attack dan man-in-the-middle.

>3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?

Dalam penggunaan `bidirectional streaming` di Rust gRPC, khususnya pada aplikasi seperti chat, tantangan utama muncul dari pengelolaan sinkronisasi pesan dan stabilitas koneksi. Karena client dan server bisa mengirim pesan secara bersamaan, dibutuhkan manajemen konkurensi yang baik agar pesan tidak tertukar urutannya atau tumpang tindih dalam pemrosesan. Selain itu, penanganan koneksi yang tidak stabil juga menjadi perhatian penting. Client bisa saja tiba-tiba memutus koneksi, dan server harus mampu mendeteksi serta menangani kondisi tersebut dengan elegan, misalnya dengan mekanisme *timeout* atau *retry*. Tantangan lainnya termasuk mencegah terjadinya *memory leak* akibat channel yang tidak tertutup dengan benar, serta menjaga performa tetap stabil ketika ada banyak koneksi aktif secara paralel. Untuk itu, penerapan strategi seperti *buffering*, *backpressure*, dan pembatasan jumlah pesan per stream perlu dipertimbangkan secara matang.

>4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?

Menggunakan `tokio_stream::wrappers::ReceiverStream` dalam layanan streaming gRPC di Rust memberikan beberapa keuntungan praktis. Salah satunya adalah kemampuannya untuk secara langsung mengubah channel Receiver menjadi stream yang kompatibel dengan `tonic`, sehingga mempermudah pengiriman data secara bertahap tanpa harus menulis implementasi manual untuk `Stream`. Selain itu, karena `ReceiverStream` bekerja di atas Tokio, ia secara natural mendukung eksekusi *asynchronous* dan dapat diintegrasikan dengan task atau runtime Tokio lainnya dengan mudah. Namun, kekurangannya terletak pada keterbatasan kontrol atas *error handling*. Jika terjadi kegagalan pada channel—seperti pengirim (Sender) ditutup tiba-tiba—stream akan berhenti tanpa banyak informasi, dan hal ini bisa sulit ditangani dalam aplikasi besar. Selain itu, karena sifatnya yang hanya satu arah (hanya mengalir dari Sender ke Receiver), fleksibilitas alur komunikasi jadi terbatas jika dibutuhkan mekanisme respon balik atau konfirmasi.

>5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?

Agar kode Rust gRPC mudah digunakan kembali dan tetap modular, struktur proyek sebaiknya dirancang dengan memisahkan tanggung jawab antar komponen. Salah satu pendekatan adalah memisahkan definisi layanan gRPC, logika bisnis, dan *layer transport* (komunikasi) ke dalam modul atau folder yang berbeda. Dengan cara ini, perubahan pada logika bisnis tidak akan memengaruhi definisi layanan, dan sebaliknya. Selain itu, penggunaan *traits* sangat disarankan untuk mendefinisikan perilaku dari service handler agar implementasi bisa diganti atau diuji dengan lebih fleksibel. Komponen seperti validasi input, logging, dan error handling juga bisa dipecah menjadi utilitas terpisah yang dapat digunakan lintas service. Mengorganisasi file berdasarkan jenis komunikasi (misalnya `unary.rs`, `streaming.rs`, `bidi.rs`) atau berdasarkan domain fitur (`payment/`, `chat/`, `transaction/`) juga dapat membuat navigasi dan pengembangan skala besar lebih mudah. Dengan arsitektur yang seperti ini, *maintainability* dan *extensibility* akan meningkat seiring bertambahnya kompleksitas aplikasi.

>6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?

Untuk menangani proses pembayaran yang lebih kompleks di MyPaymentService, diperlukan validasi data yang lebih ketat, pengecekan saldo pengguna di database, serta pencatatan transaksi secara konsisten. Selain itu, integrasi dengan sistem pembayaran eksternal dan penanganan error seperti timeout atau kegagalan jaringan juga perlu ditangani dengan baik, termasuk mekanisme *retry*, *logging*, dan pemberian respons yang sesuai kepada client. Penggunaan transaksi database dan *concurrency control* juga penting agar data tetap konsisten saat permintaan datang secara bersamaan.

>7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?

Penggunaan gRPC dalam arsitektur sistem terdistribusi memberikan dampak besar terhadap interoperabilitas, karena protokol ini menggunakan Protobuf yang bersifat lintas platform dan bahasa. Dengan satu file `.proto`, berbagai layanan yang dibangun di teknologi berbeda dapat saling berkomunikasi tanpa perlu membuat ulang kontrak data. Selain itu, gRPC berjalan di atas `HTTP/2` yang memungkinkan komunikasi lebih efisien melalui *multiplexing* dan koneksi yang persisten, sehingga cocok untuk sistem yang membutuhkan performa tinggi dan komunikasi antar layanan secara *real-time*.

>8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?

Keunggulan `HTTP/2` dibanding `HTTP/1.1` atau `HTTP/1.1` dengan WebSocket terletak pada kemampuannya melakukan *multiplexing*, yaitu mengirim banyak request-response dalam satu koneksi tanpa saling menunggu, sehingga meningkatkan efisiensi dan mengurangi latensi. *Header compression* dan dukungan streaming juga menjadikannya ideal untuk komunikasi intensif seperti pada gRPC. Namun, kekurangannya adalah kompleksitas implementasi yang lebih tinggi serta debugging yang lebih sulit dibanding protokol `HTTP/1.1`. Selain itu, karena semua komunikasi terjadi di satu koneksi, kestabilan koneksi menjadi sangat penting. Jika koneksi terganggu, semua komunikasi ikut terpengaruh.

>9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?

Model `request-response` pada REST API bersifat sinkron dan satu arah, di mana client harus selalu menunggu respons dari server setiap kali mengirim permintaan. Hal ini membatasi kemampuannya dalam menangani komunikasi *real-time*, karena setiap interaksi membutuhkan koneksi baru atau polling berkala. Sebaliknya, gRPC dengan `bidirectional` streaming memungkinkan client dan server untuk saling mengirim pesan secara terus-menerus melalui satu koneksi terbuka, sehingga lebih responsif dan efisien dalam skenario real-time seperti chat atau live update tanpa perlu membangun ulang koneksi.

>10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?

 Pendekatan berbasis skema pada gRPC melalui `Protocol Buffers` memastikan struktur data yang konsisten antara client dan server, serta memungkinkan validasi dan pembuatan kode otomatis. Ini sangat membantu dalam menjaga integritas data dan mengurangi bug akibat kesalahan format. Sebaliknya, JSON dalam REST API bersifat lebih fleksibel dan mudah diubah tanpa perlu kompilasi ulang, tetapi kurang ketat dalam hal validasi, sehingga rentan terjadi ketidaksesuaian format antara pengirim dan penerima jika tidak dikelola dengan hati-hati.